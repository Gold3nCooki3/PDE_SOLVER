mod common;

extern crate pde_solver;
extern crate ndarray; 

use pde_solver::calculate::{serial,change_index_checking, parallel};
use pde_solver::basis::{Options, CalcArguments, CalcResults, init_matrix};
use ndarray::prelude::*;
use ndarray::{arr3,arr2};

/* =========== WGET =========== */
#[test]
fn test_serial_wget_gausseidel(){
    change_index_checking(true);
    let option      = Options{
            number: 1,
            method: 1,
            interlines: 0,
            inf_func: 2,
            termination: 2,
            term_precision: 0.0,
            term_iteration: 82,
    };

    let elements = (option.interlines * 8) + 9 - 1;
    let arguments = CalcArguments {
            n: elements as usize,
            num_matrices: option.method + 1,
            h: 1.0 / elements as f64
    };

    let mut results = CalcResults{ ..Default::default()}; 
    let shape = (2,arguments.n+1, arguments.n+1);
    let mut matrix  = Array::<f64, _>::zeros(shape);
    
    serial::calc_with_get(&option, &mut results, &arguments, &mut matrix.view_mut());

    let     result_matrix = arr3(&[[[0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
                                        [0.0,0.1483426255619257, 0.27410151223833973, 0.3581309824362264, 0.3876382800010266, 0.35813115649846017, 0.27410177951680154, 0.14834284367031667, 0.0],
                                        [0.0,0.27410151223833973, 0.5064736924673121, 0.6617399364372424, 0.7162623129969206, 0.6617402335800622, 0.506474148740187, 0.2741018845726532, 0.0],
                                        [0.0,0.3581309824362263, 0.6617399364372423, 0.8646050951269443, 0.9358420130968639, 0.8646054538100575, 0.6617404872073241, 0.3581314318835014, 0.0],
                                        [0.0,0.38763828000102657, 0.7162623129969206, 0.935842013096864, 1.012948297480374, 0.9358423717799773, 0.7162628637670027, 0.38763872944830186, 0.0],
                                        [0.0,0.35813115649846017, 0.6617402335800623, 0.8646054538100575, 0.9358423717799773, 0.8646057599652452, 0.6617407036917334, 0.3581315401257061, 0.0],
                                        [0.0,0.27410177951680154, 0.506474148740187, 0.6617404872073241, 0.7162628637670027, 0.6617407036917335, 0.5064744811593379, 0.27410205078222866, 0.0],
                                        [0.0,0.14834284367031667, 0.2741018845726532, 0.3581314318835014, 0.38763872944830186, 0.35813154012570614, 0.2741020507822287, 0.1483429793030303, 0.0],
                                        [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]],
                                        [[0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
                                        [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
                                        [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
                                        [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
                                        [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
                                        [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
                                        [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
                                        [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
                                        [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]]]);
    assert!(
        result_matrix == matrix
    );
}

#[test]
fn test_serial_wget_jaconi(){
    change_index_checking(true);
    let option      = Options{
            number: 1,
            method: 2,
            interlines: 0,
            inf_func: 2,
            termination: 2,
            term_precision: 0.0,
            term_iteration: 85,
    };

    let elements = (option.interlines * 8) + 9 - 1;
    let arguments = CalcArguments {
            n: elements as usize,
            num_matrices: option.method + 1,
            h: 1.0 / elements as f64
    };

    let mut results = CalcResults{ ..Default::default()}; 
    let shape = (2,arguments.n+1, arguments.n+1);
    let mut matrix  = Array::<f64, _>::zeros(shape);
    
    serial::calc_with_get(&option, &mut results, &arguments, &mut matrix.view_mut());

    let     result_matrix = arr3(&[[[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                                    [0.0, 0.14815135460461645, 0.2737480084660539, 0.3576690095704108, 0.3871381462453182, 0.3576690095704108, 0.27374800846605385, 0.14815135460461645, 0.0],
                                    [0.0, 0.2737480084660539, 0.5058203641750273, 0.6608861547113721, 0.7153380191408216, 0.6608861547113721, 0.5058203641750273, 0.27374800846605385, 0.0],
                                    [0.0, 0.35766900957041076, 0.6608861547113722, 0.8634893737454382, 0.9346341631774261, 0.8634893737454382, 0.6608861547113721, 0.35766900957041076, 0.0],
                                    [0.0, 0.38713814624531834, 0.7153380191408216, 0.9346341631774261, 1.0116407283500546, 0.9346341631774261, 0.7153380191408216, 0.3871381462453183, 0.0],
                                    [0.0, 0.3576690095704108, 0.6608861547113721, 0.8634893737454381, 0.9346341631774261, 0.8634893737454381, 0.6608861547113721, 0.3576690095704108, 0.0],
                                    [0.0, 0.27374800846605385, 0.5058203641750272, 0.6608861547113721, 0.7153380191408215, 0.6608861547113722, 0.5058203641750273, 0.2737480084660539, 0.0],
                                    [0.0, 0.14815135460461648, 0.27374800846605385, 0.3576690095704108, 0.3871381462453183, 0.3576690095704108, 0.2737480084660539, 0.1481513546046165, 0.0],
                                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]],
                                    [[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                                    [0.0, 0.14816595814494288, 0.2737749922900734, 0.35770426563552543, 0.3871763071352114, 0.3577042656355254, 0.2737749922900734, 0.14816595814494285, 0.0],
                                    [0.0, 0.2737749922900734, 0.5058702237804683, 0.6609512994252849, 0.7154085312710509, 0.6609512994252849, 0.5058702237804683, 0.2737749922900734, 0.0],
                                    [0.0, 0.3577042656355255, 0.6609512994252847, 0.8635744894159939, 0.9347262917153583, 0.8635744894159938, 0.6609512994252847, 0.35770426563552543, 0.0],
                                    [0.0, 0.3871763071352114, 0.715408531271051, 0.9347262917153584, 1.0117404475609366, 0.9347262917153584, 0.7154085312710509, 0.3871763071352114, 0.0],
                                    [0.0, 0.3577042656355255, 0.6609512994252847, 0.8635744894159938, 0.9347262917153583, 0.8635744894159938, 0.6609512994252849, 0.3577042656355255, 0.0],
                                    [0.0, 0.27377499229007335, 0.5058702237804683, 0.6609512994252847, 0.715408531271051, 0.6609512994252847, 0.5058702237804684, 0.2737749922900734, 0.0],
                                    [0.0, 0.14816595814494285, 0.27377499229007335, 0.35770426563552543, 0.3871763071352114, 0.3577042656355255, 0.2737749922900734, 0.1481659581449429, 0.0],
                                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]]]);
    assert!(
        result_matrix == matrix
    );
}

#[test]
fn test_serial_wget_jaconi_func(){
    change_index_checking(true);
    let option      = Options{
            number: 1,
            method: 2,
            interlines: 0,
            inf_func: 1,
            termination: 2,
            term_precision: 0.0,
            term_iteration: 45,
    };

    let elements = (option.interlines * 8) + 9 - 1;
    let arguments = CalcArguments {
            n: elements as usize,
            num_matrices: option.method + 1,
            h: 1.0 / elements as f64
    };

    let mut results = CalcResults{ ..Default::default()}; 
    let shape = (2,arguments.n+1, arguments.n+1);
    let mut matrix  = Array::<f64, _>::zeros(shape);
    init_matrix::init_all(&mut matrix.view_mut(), &arguments); 
    
    serial::calc_with_get(&option, &mut results, &arguments, &mut matrix.view_mut());

    let     result_matrix = arr3(&[[[1.0, 0.875, 0.75, 0.625, 0.5, 0.375, 0.25, 0.125, 0.0],
                                    [0.875, 0.7776939879900544, 0.6809498989413793, 0.5851650609388831, 0.4907368016885527, 0.3976651056423667, 0.30594995854602397, 0.21519403269353787, 0.125],
                                    [0.75, 0.6809498989413793, 0.6128590496542747, 0.5466867024595284, 0.48283016905770637, 0.4216867620641732, 0.3628591390612419, 0.30594995854602397, 0.25],
                                    [0.625, 0.5851650609388831, 0.5466867024595284, 0.5105241595242173, 0.4776366654225891, 0.44802420422770084, 0.4216867620641732, 0.3976651056423667, 0.375],
                                    [0.5, 0.4907368016885527, 0.48283016905770637, 0.4776366654225891, 0.47571819571999363, 0.4776366654225891, 0.48283016905770637, 0.4907368016885527, 0.5],
                                    [0.375, 0.3976651056423667, 0.4216867620641732, 0.44802420422770084, 0.4776366654225891, 0.5105241595242173, 0.5466867024595284, 0.5851650609388831, 0.625],
                                    [0.25, 0.305949958546024, 0.3628591390612419, 0.4216867620641732, 0.48283016905770637, 0.5466867024595284, 0.6128590496542747, 0.6809498989413793, 0.75],
                                    [0.125, 0.21519403269353787, 0.30594995854602397, 0.3976651056423667, 0.4907368016885527, 0.5851650609388831, 0.6809498989413793, 0.7776939879900543, 0.875],
                                    [0.0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0]],
                                    [[1.0, 0.875, 0.75, 0.625, 0.5, 0.375, 0.25, 0.125, 0.0],
                                    [0.875, 0.7779749494706896, 0.6814295246458031, 0.585843350772365, 0.4914150839097391, 0.39834338057468743, 0.3064295693492866, 0.21547497927301196, 0.125],
                                    [0.75, 0.6814295246458031, 0.6138183007004538, 0.5478446097937704, 0.48418673290871084, 0.42284465449725395, 0.3638183603050986, 0.3064295693492866, 0.25],
                                    [0.625, 0.585843350772365, 0.5478446097937704, 0.5121616839410588, 0.4792741821324045, 0.44966171374338115, 0.42284465449725395, 0.3983433805746875, 0.375],
                                    [0.5, 0.4914150839097391, 0.48418673290871084, 0.47927418213240447, 0.4776366654225891, 0.47927418213240447, 0.48418673290871084, 0.4914150839097391, 0.5],
                                    [0.375, 0.39834338057468743, 0.42284465449725395, 0.44966171374338115, 0.4792741821324045, 0.5121616839410588, 0.5478446097937704, 0.585843350772365, 0.625],
                                    [0.25, 0.30642956934928667, 0.3638183603050986, 0.42284465449725395, 0.4841867329087109, 0.5478446097937704, 0.6138183007004538, 0.6814295246458031, 0.75],
                                    [0.125, 0.215474979273012, 0.3064295693492866, 0.3983433805746875, 0.49141508390973904, 0.585843350772365, 0.6814295246458031, 0.7779749494706896, 0.875],
                                    [0.0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0]]]);
    assert!(
        result_matrix == matrix
    );
}

#[test]
fn test_serial_wget_gausseidel_func(){
    change_index_checking(true);
    let option      = Options{
            number: 1,
            method: 1,
            interlines: 0,
            inf_func: 1,
            termination: 2,
            term_precision: 0.0,
            term_iteration: 45,
    };

    let elements = (option.interlines * 8) + 9 - 1;
    let arguments = CalcArguments {
            n: elements as usize,
            num_matrices: option.method + 1,
            h: 1.0 / elements as f64
    };

    let mut results = CalcResults{ ..Default::default()}; 
    let shape = (2,arguments.n+1, arguments.n+1);
    let mut matrix  = Array::<f64, _>::zeros(shape);
    init_matrix::init_all(&mut matrix.view_mut(), &arguments);

    serial::calc_with_get(&option, &mut results, &arguments, &mut matrix.view_mut());

    let     result_matrix = arr3(&[[[1.0, 0.875, 0.75, 0.625, 0.5, 0.375, 0.25, 0.125, 0.0],
                                    [0.875, 0.7810865300111444, 0.6872209360230219, 0.5934131359270588, 0.49966313224858033, 0.4059624628705278, 0.3122966793135369, 0.21864833931976357, 0.125],
                                    [0.75, 0.6872209360230219, 0.6245236033997545, 0.5619249326498502, 0.49942492739401734, 0.4370091412492732, 0.37465290872675916, 0.31232645391514346, 0.25],
                                    [0.625, 0.5934131359270588, 0.5619249326498502, 0.5305558266582965, 0.4993058215159541, 0.4681574781337299, 0.4370810221508293, 0.4060405106928212, 0.375],
                                    [0.5, 0.4996631322485804, 0.4994249273940172, 0.49930582151595404, 0.4993058174534686, 0.49940747543204633, 0.499581020654563, 0.4997905100884853, 0.5],
                                    [0.375, 0.4059624628705278, 0.4370091412492732, 0.46815747813372977, 0.49940747543204633, 0.5307442468810555, 0.5621423778006582, 0.5935711887949384, 0.625],
                                    [0.25, 0.3122966793135369, 0.3746529087267591, 0.4370810221508292, 0.499581020654563, 0.5621423778006582, 0.6247471225456341, 0.6873735612464693, 0.75],
                                    [0.125, 0.21864833931976357, 0.31232645391514346, 0.4060405106928212, 0.4997905100884853, 0.5935711887949384, 0.6873735612464693, 0.7811867806232347, 0.875],
                                    [0.0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0]],
                                    [[1.0, 0.875, 0.75, 0.625, 0.5, 0.375, 0.25, 0.125, 0.0],
                                    [0.875, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.125],
                                    [0.75, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.25],
                                    [0.625, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.375],
                                    [0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5],
                                    [0.375, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.625],
                                    [0.25, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.75],
                                    [0.125, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.875],
                                    [0.0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0]]]);
    assert!(
        result_matrix == matrix
    );
}

/* =========== UGET =========== */
#[test] 
#[ignore]
fn test_serial_uget_jaconi(){
    change_index_checking(false);
    let option      = Options{
            number: 1,
            method: 2,
            interlines: 0,
            inf_func: 2,
            termination: 1,
            term_precision: 5e-5,
            term_iteration: 200000,
    };

    let elements = (option.interlines * 8) + 9 - 1;
    let arguments = CalcArguments {
            n: elements as usize,
            num_matrices: option.method + 1,
            h: 1.0 / elements as f64
    };

    let mut results = CalcResults{ ..Default::default()}; 
    let shape = (2,arguments.n+1, arguments.n+1);
    let mut matrix  = Array::<f64, _>::zeros(shape);
    
    serial::calc_with_get(&option, &mut results, &arguments, &mut matrix.view_mut());

    let     result_matrix = arr3(&[[[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                                    [0.0, 0.14825628426495077, 0.2739418931971263, 0.3579223321794851, 0.387412340661538, 0.3579223321794851, 0.2739418931971263, 0.14825628426495077, 0.0],
                                    [0.0, 0.2739418931971263, 0.5061786164444358, 0.6613542338586643, 0.7158446643589702, 0.6613542338586643, 0.5061786164444358, 0.2739418931971263, 0.0],
                                    [0.0, 0.3579223321794851, 0.6613542338586643, 0.8641009486239211, 0.9352961270557907, 0.8641009486239211, 0.6613542338586643, 0.3579223321794851, 0.0],
                                    [0.0, 0.387412340661538, 0.7158446643589702, 0.9352961270557907, 1.012357232888872, 0.9352961270557909, 0.7158446643589702, 0.387412340661538, 0.0],
                                    [0.0, 0.3579223321794851, 0.6613542338586643, 0.864100948623921, 0.9352961270557909, 0.864100948623921, 0.6613542338586644, 0.35792233217948516, 0.0],
                                    [0.0, 0.2739418931971263, 0.5061786164444358, 0.6613542338586643, 0.7158446643589701, 0.6613542338586644, 0.506178616444436, 0.27394189319712636, 0.0],
                                    [0.0, 0.14825628426495077, 0.2739418931971263, 0.35792233217948505, 0.387412340661538, 0.3579223321794851, 0.27394189319712636, 0.1482562842649508, 0.0],
                                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]],
                                    [[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                                    [0.0, 0.14824912289239572, 0.2739286607060697, 0.35790504309673743, 0.3873936270932217, 0.35790504309673743, 0.2739286607060697, 0.1482491228923957, 0.0],
                                    [0.0, 0.2739286607060697, 0.5061541659891331, 0.6613222877992916, 0.7158100861934749, 0.6613222877992914, 0.5061541659891331, 0.2739286607060697, 0.0],
                                    [0.0, 0.35790504309673743, 0.6613222877992915, 0.8640592090858706, 0.9352509485053614, 0.8640592090858706, 0.6613222877992915, 0.35790504309673743, 0.0],
                                    [0.0, 0.3873936270932217, 0.7158100861934749, 0.9352509485053613, 1.0123083319782664, 0.9352509485053614, 0.7158100861934749, 0.3873936270932218, 0.0],
                                    [0.0, 0.35790504309673743, 0.6613222877992914, 0.8640592090858706, 0.9352509485053613, 0.8640592090858707, 0.6613222877992915, 0.35790504309673743, 0.0],
                                    [0.0, 0.2739286607060697, 0.5061541659891331, 0.6613222877992914, 0.715810086193475, 0.6613222877992915, 0.5061541659891332, 0.27392866070606975, 0.0],
                                    [0.0, 0.1482491228923957, 0.2739286607060697, 0.35790504309673743, 0.3873936270932217, 0.3579050430967375, 0.2739286607060697, 0.14824912289239575, 0.0],
                                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]]]);
    assert!(
        result_matrix == matrix
    );
}

#[test]
#[ignore]
fn test_serial_uget_gausseidel(){
    change_index_checking(false);
    let option      = Options{
            number: 1,
            method: 1,
            interlines: 0,
            inf_func: 2,
            termination: 2,
            term_precision: 0.0,
            term_iteration: 82,
    };

    let elements = (option.interlines * 8) + 9 - 1;
    let arguments = CalcArguments {
            n: elements as usize,
            num_matrices: option.method + 1,
            h: 1.0 / elements as f64
    };

    let mut results = CalcResults{ ..Default::default()}; 
    let shape = (2,arguments.n+1, arguments.n+1);
    let mut matrix  = Array::<f64, _>::zeros(shape);
    
    serial::calc_with_get(&option, &mut results, &arguments, &mut matrix.view_mut());

    let     result_matrix = arr3(&[[[0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
                                        [0.0,0.1483426255619257, 0.27410151223833973, 0.3581309824362264, 0.3876382800010266, 0.35813115649846017, 0.27410177951680154, 0.14834284367031667, 0.0],
                                        [0.0,0.27410151223833973, 0.5064736924673121, 0.6617399364372424, 0.7162623129969206, 0.6617402335800622, 0.506474148740187, 0.2741018845726532, 0.0],
                                        [0.0,0.3581309824362263, 0.6617399364372423, 0.8646050951269443, 0.9358420130968639, 0.8646054538100575, 0.6617404872073241, 0.3581314318835014, 0.0],
                                        [0.0,0.38763828000102657, 0.7162623129969206, 0.935842013096864, 1.012948297480374, 0.9358423717799773, 0.7162628637670027, 0.38763872944830186, 0.0],
                                        [0.0,0.35813115649846017, 0.6617402335800623, 0.8646054538100575, 0.9358423717799773, 0.8646057599652452, 0.6617407036917334, 0.3581315401257061, 0.0],
                                        [0.0,0.27410177951680154, 0.506474148740187, 0.6617404872073241, 0.7162628637670027, 0.6617407036917335, 0.5064744811593379, 0.27410205078222866, 0.0],
                                        [0.0,0.14834284367031667, 0.2741018845726532, 0.3581314318835014, 0.38763872944830186, 0.35813154012570614, 0.2741020507822287, 0.1483429793030303, 0.0],
                                        [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]],
                                        [[0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
                                        [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
                                        [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
                                        [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
                                        [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
                                        [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
                                        [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
                                        [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
                                        [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]]]);
    assert!(
        result_matrix == matrix
    );
}

/* =========== PARALLEL GET =========== */

#[test]
fn test_parallel_crossbeam_jaconi(){
    change_index_checking(false);
    let option      = Options{
            number: 3,
            method: 2,
            interlines: 0,
            inf_func: 2,
            termination: 1,
            term_precision: 5e-5,
            term_iteration: 200000,
    };

    let elements = (option.interlines * 8) + 9 - 1;
    let arguments = CalcArguments {
            n: elements as usize,
            num_matrices: option.method + 1,
            h: 1.0 / elements as f64
    };

    let mut results = CalcResults{ ..Default::default()}; 
    let shape = (2,arguments.n+1, arguments.n+1);
    let mut matrix  = Array::<f64, _>::zeros(shape);
    
    parallel::calc_get_with_crossbeam(&option, &mut results, &arguments, &mut  matrix.view_mut());

    let     result_matrix = arr3(&[[[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                                    [0.0, 0.14825628426495077, 0.2739418931971263, 0.3579223321794851, 0.387412340661538, 0.3579223321794851, 0.2739418931971263, 0.14825628426495077, 0.0],
                                    [0.0, 0.2739418931971263, 0.5061786164444358, 0.6613542338586643, 0.7158446643589702, 0.6613542338586643, 0.5061786164444358, 0.2739418931971263, 0.0],
                                    [0.0, 0.3579223321794851, 0.6613542338586643, 0.8641009486239211, 0.9352961270557907, 0.8641009486239211, 0.6613542338586643, 0.3579223321794851, 0.0],
                                    [0.0, 0.387412340661538, 0.7158446643589702, 0.9352961270557907, 1.012357232888872, 0.9352961270557909, 0.7158446643589702, 0.387412340661538, 0.0],
                                    [0.0, 0.3579223321794851, 0.6613542338586643, 0.864100948623921, 0.9352961270557909, 0.864100948623921, 0.6613542338586644, 0.35792233217948516, 0.0],
                                    [0.0, 0.2739418931971263, 0.5061786164444358, 0.6613542338586643, 0.7158446643589701, 0.6613542338586644, 0.506178616444436, 0.27394189319712636, 0.0],
                                    [0.0, 0.14825628426495077, 0.2739418931971263, 0.35792233217948505, 0.387412340661538, 0.3579223321794851, 0.27394189319712636, 0.1482562842649508, 0.0],
                                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]],
                                    [[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                                    [0.0, 0.14824912289239572, 0.2739286607060697, 0.35790504309673743, 0.3873936270932217, 0.35790504309673743, 0.2739286607060697, 0.1482491228923957, 0.0],
                                    [0.0, 0.2739286607060697, 0.5061541659891331, 0.6613222877992916, 0.7158100861934749, 0.6613222877992914, 0.5061541659891331, 0.2739286607060697, 0.0],
                                    [0.0, 0.35790504309673743, 0.6613222877992915, 0.8640592090858706, 0.9352509485053614, 0.8640592090858706, 0.6613222877992915, 0.35790504309673743, 0.0],
                                    [0.0, 0.3873936270932217, 0.7158100861934749, 0.9352509485053613, 1.0123083319782664, 0.9352509485053614, 0.7158100861934749, 0.3873936270932218, 0.0],
                                    [0.0, 0.35790504309673743, 0.6613222877992914, 0.8640592090858706, 0.9352509485053613, 0.8640592090858707, 0.6613222877992915, 0.35790504309673743, 0.0],
                                    [0.0, 0.2739286607060697, 0.5061541659891331, 0.6613222877992914, 0.715810086193475, 0.6613222877992915, 0.5061541659891332, 0.27392866070606975, 0.0],
                                    [0.0, 0.1482491228923957, 0.2739286607060697, 0.35790504309673743, 0.3873936270932217, 0.3579050430967375, 0.2739286607060697, 0.14824912289239575, 0.0],
                                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]]]);
    println!("{}", matrix);  
    assert!(
        result_matrix == matrix
    );
}

#[test]
fn test_parallel_crossbeam_jaconi_func(){
    change_index_checking(true);
    let option      = Options{
            number: 4,
            method: 2,
            interlines: 0,
            inf_func: 1,
            termination: 2,
            term_precision: 0.0,
            term_iteration: 45,
    };

    let elements = (option.interlines * 8) + 9 - 1;
    let arguments = CalcArguments {
            n: elements as usize,
            num_matrices: option.method + 1,
            h: 1.0 / elements as f64
    };

    let mut results = CalcResults{ ..Default::default()}; 
    let shape = (2,arguments.n+1, arguments.n+1);
    let mut matrix  = Array::<f64, _>::zeros(shape);
    init_matrix::init_all(&mut matrix.view_mut(), &arguments); 
    
    parallel::calc_get_with_crossbeam(&option, &mut results, &arguments, &mut  matrix.view_mut());

    let     result_matrix = arr3(&[[[1.0, 0.875, 0.75, 0.625, 0.5, 0.375, 0.25, 0.125, 0.0],
                                    [0.875, 0.7776939879900544, 0.6809498989413793, 0.5851650609388831, 0.4907368016885527, 0.3976651056423667, 0.30594995854602397, 0.21519403269353787, 0.125],
                                    [0.75, 0.6809498989413793, 0.6128590496542747, 0.5466867024595284, 0.48283016905770637, 0.4216867620641732, 0.3628591390612419, 0.30594995854602397, 0.25],
                                    [0.625, 0.5851650609388831, 0.5466867024595284, 0.5105241595242173, 0.4776366654225891, 0.44802420422770084, 0.4216867620641732, 0.3976651056423667, 0.375],
                                    [0.5, 0.4907368016885527, 0.48283016905770637, 0.4776366654225891, 0.47571819571999363, 0.4776366654225891, 0.48283016905770637, 0.4907368016885527, 0.5],
                                    [0.375, 0.3976651056423667, 0.4216867620641732, 0.44802420422770084, 0.4776366654225891, 0.5105241595242173, 0.5466867024595284, 0.5851650609388831, 0.625],
                                    [0.25, 0.305949958546024, 0.3628591390612419, 0.4216867620641732, 0.48283016905770637, 0.5466867024595284, 0.6128590496542747, 0.6809498989413793, 0.75],
                                    [0.125, 0.21519403269353787, 0.30594995854602397, 0.3976651056423667, 0.4907368016885527, 0.5851650609388831, 0.6809498989413793, 0.7776939879900543, 0.875],
                                    [0.0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0]],
                                    [[1.0, 0.875, 0.75, 0.625, 0.5, 0.375, 0.25, 0.125, 0.0],
                                    [0.875, 0.7779749494706896, 0.6814295246458031, 0.585843350772365, 0.4914150839097391, 0.39834338057468743, 0.3064295693492866, 0.21547497927301196, 0.125],
                                    [0.75, 0.6814295246458031, 0.6138183007004538, 0.5478446097937704, 0.48418673290871084, 0.42284465449725395, 0.3638183603050986, 0.3064295693492866, 0.25],
                                    [0.625, 0.585843350772365, 0.5478446097937704, 0.5121616839410588, 0.4792741821324045, 0.44966171374338115, 0.42284465449725395, 0.3983433805746875, 0.375],
                                    [0.5, 0.4914150839097391, 0.48418673290871084, 0.47927418213240447, 0.4776366654225891, 0.47927418213240447, 0.48418673290871084, 0.4914150839097391, 0.5],
                                    [0.375, 0.39834338057468743, 0.42284465449725395, 0.44966171374338115, 0.4792741821324045, 0.5121616839410588, 0.5478446097937704, 0.585843350772365, 0.625],
                                    [0.25, 0.30642956934928667, 0.3638183603050986, 0.42284465449725395, 0.4841867329087109, 0.5478446097937704, 0.6138183007004538, 0.6814295246458031, 0.75],
                                    [0.125, 0.215474979273012, 0.3064295693492866, 0.3983433805746875, 0.49141508390973904, 0.585843350772365, 0.6814295246458031, 0.7779749494706896, 0.875],
                                    [0.0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0]]]);

                                  
    assert!(
        result_matrix == matrix
    );
}

#[test]
fn test_parallel_threadpool_jaconi(){
    change_index_checking(false);
    let option      = Options{
            number: 3,
            method: 2,
            interlines: 0,
            inf_func: 2,
            termination: 1,
            term_precision: 5e-5,
            term_iteration: 200000,
    };

    let elements = (option.interlines * 8) + 9 - 1;
    let arguments = CalcArguments {
            n: elements as usize,
            num_matrices: option.method + 1,
            h: 1.0 / elements as f64
    };

    let mut results = CalcResults{ ..Default::default()}; 
    let shape = (2,arguments.n+1, arguments.n+1);
    let mut matrix  = Array::<f64, _>::zeros(shape);
    
    parallel::calc_get_with_threadpool(&option, &mut results, &arguments, &mut  matrix.view_mut());

    let     result_matrix = arr3(&[[[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                                    [0.0, 0.14825628426495077, 0.2739418931971263, 0.3579223321794851, 0.387412340661538, 0.3579223321794851, 0.2739418931971263, 0.14825628426495077, 0.0],
                                    [0.0, 0.2739418931971263, 0.5061786164444358, 0.6613542338586643, 0.7158446643589702, 0.6613542338586643, 0.5061786164444358, 0.2739418931971263, 0.0],
                                    [0.0, 0.3579223321794851, 0.6613542338586643, 0.8641009486239211, 0.9352961270557907, 0.8641009486239211, 0.6613542338586643, 0.3579223321794851, 0.0],
                                    [0.0, 0.387412340661538, 0.7158446643589702, 0.9352961270557907, 1.012357232888872, 0.9352961270557909, 0.7158446643589702, 0.387412340661538, 0.0],
                                    [0.0, 0.3579223321794851, 0.6613542338586643, 0.864100948623921, 0.9352961270557909, 0.864100948623921, 0.6613542338586644, 0.35792233217948516, 0.0],
                                    [0.0, 0.2739418931971263, 0.5061786164444358, 0.6613542338586643, 0.7158446643589701, 0.6613542338586644, 0.506178616444436, 0.27394189319712636, 0.0],
                                    [0.0, 0.14825628426495077, 0.2739418931971263, 0.35792233217948505, 0.387412340661538, 0.3579223321794851, 0.27394189319712636, 0.1482562842649508, 0.0],
                                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]],
                                    [[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                                    [0.0, 0.14824912289239572, 0.2739286607060697, 0.35790504309673743, 0.3873936270932217, 0.35790504309673743, 0.2739286607060697, 0.1482491228923957, 0.0],
                                    [0.0, 0.2739286607060697, 0.5061541659891331, 0.6613222877992916, 0.7158100861934749, 0.6613222877992914, 0.5061541659891331, 0.2739286607060697, 0.0],
                                    [0.0, 0.35790504309673743, 0.6613222877992915, 0.8640592090858706, 0.9352509485053614, 0.8640592090858706, 0.6613222877992915, 0.35790504309673743, 0.0],
                                    [0.0, 0.3873936270932217, 0.7158100861934749, 0.9352509485053613, 1.0123083319782664, 0.9352509485053614, 0.7158100861934749, 0.3873936270932218, 0.0],
                                    [0.0, 0.35790504309673743, 0.6613222877992914, 0.8640592090858706, 0.9352509485053613, 0.8640592090858707, 0.6613222877992915, 0.35790504309673743, 0.0],
                                    [0.0, 0.2739286607060697, 0.5061541659891331, 0.6613222877992914, 0.715810086193475, 0.6613222877992915, 0.5061541659891332, 0.27392866070606975, 0.0],
                                    [0.0, 0.1482491228923957, 0.2739286607060697, 0.35790504309673743, 0.3873936270932217, 0.3579050430967375, 0.2739286607060697, 0.14824912289239575, 0.0],
                                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]]]);
    println!("{}", matrix);  
    assert!(
        result_matrix == matrix
    );
}

#[test]
fn test_parallel_threadpool_jaconi_func(){
    change_index_checking(true);
    let option      = Options{
            number: 1,
            method: 2,
            interlines: 0,
            inf_func: 1,
            termination: 2,
            term_precision: 0.0,
            term_iteration: 45,
    };

    let elements = (option.interlines * 8) + 9 - 1;
    let arguments = CalcArguments {
            n: elements as usize,
            num_matrices: option.method + 1,
            h: 1.0 / elements as f64
    };

    let mut results = CalcResults{ ..Default::default()}; 
    let shape = (2,arguments.n+1, arguments.n+1);
    let mut matrix  = Array::<f64, _>::zeros(shape);
    init_matrix::init_all(&mut matrix.view_mut(), &arguments); 
    
    parallel::calc_get_with_threadpool(&option, &mut results, &arguments, &mut  matrix.view_mut());

    let     result_matrix = arr3(&[[[1.0, 0.875, 0.75, 0.625, 0.5, 0.375, 0.25, 0.125, 0.0],
                                    [0.875, 0.7776939879900544, 0.6809498989413793, 0.5851650609388831, 0.4907368016885527, 0.3976651056423667, 0.30594995854602397, 0.21519403269353787, 0.125],
                                    [0.75, 0.6809498989413793, 0.6128590496542747, 0.5466867024595284, 0.48283016905770637, 0.4216867620641732, 0.3628591390612419, 0.30594995854602397, 0.25],
                                    [0.625, 0.5851650609388831, 0.5466867024595284, 0.5105241595242173, 0.4776366654225891, 0.44802420422770084, 0.4216867620641732, 0.3976651056423667, 0.375],
                                    [0.5, 0.4907368016885527, 0.48283016905770637, 0.4776366654225891, 0.47571819571999363, 0.4776366654225891, 0.48283016905770637, 0.4907368016885527, 0.5],
                                    [0.375, 0.3976651056423667, 0.4216867620641732, 0.44802420422770084, 0.4776366654225891, 0.5105241595242173, 0.5466867024595284, 0.5851650609388831, 0.625],
                                    [0.25, 0.305949958546024, 0.3628591390612419, 0.4216867620641732, 0.48283016905770637, 0.5466867024595284, 0.6128590496542747, 0.6809498989413793, 0.75],
                                    [0.125, 0.21519403269353787, 0.30594995854602397, 0.3976651056423667, 0.4907368016885527, 0.5851650609388831, 0.6809498989413793, 0.7776939879900543, 0.875],
                                    [0.0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0]],
                                    [[1.0, 0.875, 0.75, 0.625, 0.5, 0.375, 0.25, 0.125, 0.0],
                                    [0.875, 0.7779749494706896, 0.6814295246458031, 0.585843350772365, 0.4914150839097391, 0.39834338057468743, 0.3064295693492866, 0.21547497927301196, 0.125],
                                    [0.75, 0.6814295246458031, 0.6138183007004538, 0.5478446097937704, 0.48418673290871084, 0.42284465449725395, 0.3638183603050986, 0.3064295693492866, 0.25],
                                    [0.625, 0.585843350772365, 0.5478446097937704, 0.5121616839410588, 0.4792741821324045, 0.44966171374338115, 0.42284465449725395, 0.3983433805746875, 0.375],
                                    [0.5, 0.4914150839097391, 0.48418673290871084, 0.47927418213240447, 0.4776366654225891, 0.47927418213240447, 0.48418673290871084, 0.4914150839097391, 0.5],
                                    [0.375, 0.39834338057468743, 0.42284465449725395, 0.44966171374338115, 0.4792741821324045, 0.5121616839410588, 0.5478446097937704, 0.585843350772365, 0.625],
                                    [0.25, 0.30642956934928667, 0.3638183603050986, 0.42284465449725395, 0.4841867329087109, 0.5478446097937704, 0.6138183007004538, 0.6814295246458031, 0.75],
                                    [0.125, 0.215474979273012, 0.3064295693492866, 0.3983433805746875, 0.49141508390973904, 0.585843350772365, 0.6814295246458031, 0.7779749494706896, 0.875],
                                    [0.0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0]]]);
    assert!(
        result_matrix == matrix
    );
}

/* =========== ITERATORS =========== */
#[test]
fn test_serial_iterators_gausseidel(){
    let option      = Options{
            number: 1,
            method: 1,
            interlines: 0,
            inf_func: 2,
            termination: 2,
            term_precision: 0.0,
            term_iteration: 82,
    };

    let elements = (option.interlines * 8) + 9 - 1;
    let arguments = CalcArguments {
            n: elements as usize,
            num_matrices: option.method + 1,
            h: 1.0 / elements as f64
    };

    let mut results = CalcResults{ ..Default::default()}; 
    let shape = (2, arguments.n+1, arguments.n+1);
    let mut matrix  = Array::<f64, _>::zeros(shape);
    
    serial::calc_with_iterators(&option, &mut results, &arguments, &mut matrix.view_mut());
    
    let     result_matrix = arr2(&[[0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
                                        [0.0,0.1483426255619257, 0.27410151223833973, 0.3581309824362264, 0.3876382800010266, 0.35813115649846017, 0.27410177951680154, 0.14834284367031667, 0.0],
                                        [0.0,0.27410151223833973, 0.5064736924673121, 0.6617399364372424, 0.7162623129969206, 0.6617402335800622, 0.506474148740187, 0.2741018845726532, 0.0],
                                        [0.0,0.3581309824362263, 0.6617399364372423, 0.8646050951269443, 0.9358420130968639, 0.8646054538100575, 0.6617404872073241, 0.3581314318835014, 0.0],
                                        [0.0,0.38763828000102657, 0.7162623129969206, 0.935842013096864, 1.012948297480374, 0.9358423717799773, 0.7162628637670027, 0.38763872944830186, 0.0],
                                        [0.0,0.35813115649846017, 0.6617402335800623, 0.8646054538100575, 0.9358423717799773, 0.8646057599652452, 0.6617407036917334, 0.3581315401257061, 0.0],
                                        [0.0,0.27410177951680154, 0.506474148740187, 0.6617404872073241, 0.7162628637670027, 0.6617407036917335, 0.5064744811593379, 0.27410205078222866, 0.0],
                                        [0.0,0.14834284367031667, 0.2741018845726532, 0.3581314318835014, 0.38763872944830186, 0.35813154012570614, 0.2741020507822287, 0.1483429793030303, 0.0],
                                        [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]]);
 
    println!("{}", matrix.subview(Axis(0), results.m));

    assert!(
        result_matrix == matrix.subview(Axis(0), results.m)
    );
}

#[test]
fn test_serial_iterators_jaconi(){
    let option      = Options{
            number: 1,
            method: 2,
            interlines: 0,
            inf_func: 2,
            termination: 1,
            term_precision: 5e-5,
            term_iteration: 200000,
    };

    let elements = (option.interlines * 8) + 9 - 1;
    let arguments = CalcArguments {
            n: elements as usize,
            num_matrices: option.method + 1,
            h: 1.0 / elements as f64
    };

    let mut results = CalcResults{ ..Default::default()}; 
    let shape = (2, arguments.n+1, arguments.n+1);
    let mut matrix  = Array::<f64, _>::zeros(shape);
    
    serial::calc_with_iterators(&option, &mut results, &arguments, &mut matrix.view_mut());
    
    let     result_matrix = arr2(&[[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                                    [0.0, 0.14825628426495077, 0.2739418931971263, 0.3579223321794851, 0.387412340661538, 0.3579223321794851, 0.2739418931971263, 0.14825628426495077, 0.0],
                                    [0.0, 0.2739418931971263, 0.5061786164444358, 0.6613542338586643, 0.7158446643589702, 0.6613542338586643, 0.5061786164444358, 0.2739418931971263, 0.0],
                                    [0.0, 0.3579223321794851, 0.6613542338586643, 0.8641009486239211, 0.9352961270557907, 0.8641009486239211, 0.6613542338586643, 0.3579223321794851, 0.0],
                                    [0.0, 0.387412340661538, 0.7158446643589702, 0.9352961270557907, 1.012357232888872, 0.9352961270557909, 0.7158446643589702, 0.387412340661538, 0.0],
                                    [0.0, 0.3579223321794851, 0.6613542338586643, 0.864100948623921, 0.9352961270557909, 0.864100948623921, 0.6613542338586644, 0.35792233217948516, 0.0],
                                    [0.0, 0.2739418931971263, 0.5061786164444358, 0.6613542338586643, 0.7158446643589701, 0.6613542338586644, 0.506178616444436, 0.27394189319712636, 0.0],
                                    [0.0, 0.14825628426495077, 0.2739418931971263, 0.35792233217948505, 0.387412340661538, 0.3579223321794851, 0.27394189319712636, 0.1482562842649508, 0.0],
                                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]]);

    println!("{:?}", matrix);

    assert!(
        result_matrix == matrix.subview(Axis(0), results.m)
    );
}

#[test]
fn test_serial_iterators_gausseidel_func(){
    let option      = Options{
            number: 1,
            method: 1,
            interlines: 0,
            inf_func: 1,
            termination: 2,
            term_precision: 0.0,
            term_iteration: 45,
    };

    let elements = (option.interlines * 8) + 9 - 1;
    let arguments = CalcArguments {
            n: elements as usize,
            num_matrices: option.method + 1,
            h: 1.0 / elements as f64
    };

    let mut results = CalcResults{ ..Default::default()}; 
    let shape = (2, arguments.n+1, arguments.n+1);
    let mut matrix  = Array::<f64, _>::zeros(shape);
    init_matrix::init_all(&mut matrix.view_mut(), &arguments);

    serial::calc_with_iterators(&option, &mut results, &arguments, &mut matrix.view_mut());
    
    let     result_matrix = arr2(&[[1.0, 0.875, 0.75, 0.625, 0.5, 0.375, 0.25, 0.125, 0.0],
                                    [0.875, 0.7810865300111444, 0.6872209360230219, 0.5934131359270588, 0.49966313224858033, 0.4059624628705278, 0.3122966793135369, 0.21864833931976357, 0.125],
                                    [0.75, 0.6872209360230219, 0.6245236033997545, 0.5619249326498502, 0.49942492739401734, 0.4370091412492732, 0.37465290872675916, 0.31232645391514346, 0.25],
                                    [0.625, 0.5934131359270588, 0.5619249326498502, 0.5305558266582965, 0.4993058215159541, 0.4681574781337299, 0.4370810221508293, 0.4060405106928212, 0.375],
                                    [0.5, 0.4996631322485804, 0.4994249273940172, 0.49930582151595404, 0.4993058174534686, 0.49940747543204633, 0.499581020654563, 0.4997905100884853, 0.5],
                                    [0.375, 0.4059624628705278, 0.4370091412492732, 0.46815747813372977, 0.49940747543204633, 0.5307442468810555, 0.5621423778006582, 0.5935711887949384, 0.625],
                                    [0.25, 0.3122966793135369, 0.3746529087267591, 0.4370810221508292, 0.499581020654563, 0.5621423778006582, 0.6247471225456341, 0.6873735612464693, 0.75],
                                    [0.125, 0.21864833931976357, 0.31232645391514346, 0.4060405106928212, 0.4997905100884853, 0.5935711887949384, 0.6873735612464693, 0.7811867806232347, 0.875],
                                    [0.0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0]]);
    
    println!("{}", matrix.subview(Axis(0), results.m));

    assert!(
        result_matrix == matrix.subview(Axis(0), results.m)
    );
}

#[test]
fn test_serial_iterators_jaconi_func(){
    let option      = Options{
            number: 1,
            method: 2,
            interlines: 0,
            inf_func: 1,
            termination: 2,
            term_precision: 0.0,
            term_iteration: 45,
    };

    let elements = (option.interlines * 8) + 9 - 1;
    let arguments = CalcArguments {
            n: elements as usize,
            num_matrices: option.method + 1,
            h: 1.0 / elements as f64
    };

    let mut results = CalcResults{ ..Default::default()}; 
    let shape = (2, arguments.n+1, arguments.n+1);
    let mut matrix  = Array::<f64, _>::zeros(shape); 
    init_matrix::init_all(&mut matrix.view_mut(), &arguments);

    serial::calc_with_iterators(&option, &mut results, &arguments, &mut matrix.view_mut());
    
    let     result_matrix = arr2(&[[1.0, 0.875, 0.75, 0.625, 0.5, 0.375, 0.25, 0.125, 0.0],
                                    [0.875, 0.7779749494706896, 0.6814295246458031, 0.585843350772365, 0.4914150839097391, 0.39834338057468743, 0.3064295693492866, 0.21547497927301196, 0.125],
                                    [0.75, 0.6814295246458031, 0.6138183007004538, 0.5478446097937704, 0.48418673290871084, 0.42284465449725395, 0.3638183603050986, 0.3064295693492866, 0.25],
                                    [0.625, 0.585843350772365, 0.5478446097937704, 0.5121616839410588, 0.4792741821324045, 0.44966171374338115, 0.42284465449725395, 0.3983433805746875, 0.375],
                                    [0.5, 0.4914150839097391, 0.48418673290871084, 0.47927418213240447, 0.4776366654225891, 0.47927418213240447, 0.48418673290871084, 0.4914150839097391, 0.5],
                                    [0.375, 0.39834338057468743, 0.42284465449725395, 0.44966171374338115, 0.4792741821324045, 0.5121616839410588, 0.5478446097937704, 0.585843350772365, 0.625],
                                    [0.25, 0.30642956934928667, 0.3638183603050986, 0.42284465449725395, 0.4841867329087109, 0.5478446097937704, 0.6138183007004538, 0.6814295246458031, 0.75],
                                    [0.125, 0.215474979273012, 0.3064295693492866, 0.3983433805746875, 0.49141508390973904, 0.585843350772365, 0.6814295246458031, 0.7779749494706896, 0.875],
                                    [0.0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0]]);
    
    println!("{}", matrix.subview(Axis(0), results.m));

    assert!(
        result_matrix == matrix.subview(Axis(0), results.m)
    );
}

#[test]
fn test_parallel_iterators_jaconi(){
    let option      = Options{
            number: 2,
            method: 2,
            interlines: 0,
            inf_func: 2,
            termination: 2,
            term_precision: 0e0,
            term_iteration: 94,
    };

    let elements = (option.interlines * 8) + 9 - 1;
    let arguments = CalcArguments {
            n: elements as usize,
            num_matrices: option.method + 1,
            h: 1.0 / elements as f64
    };

    let mut results = CalcResults{ ..Default::default()}; 
    let shape = (2, arguments.n+1, arguments.n+1);
    let mut matrix  = Array::<f64, _>::zeros(shape);
    
    parallel::calc_with_iterators(&option, &mut results, &arguments, &mut matrix.view_mut());
    
    let     result_matrix = arr2(&[[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                                    [0.0, 0.14825628426495077, 0.2739418931971263, 0.3579223321794851, 0.387412340661538, 0.3579223321794851, 0.2739418931971263, 0.14825628426495077, 0.0],
                                    [0.0, 0.2739418931971263, 0.5061786164444358, 0.6613542338586643, 0.7158446643589702, 0.6613542338586643, 0.5061786164444358, 0.2739418931971263, 0.0],
                                    [0.0, 0.3579223321794851, 0.6613542338586643, 0.8641009486239211, 0.9352961270557907, 0.8641009486239211, 0.6613542338586643, 0.3579223321794851, 0.0],
                                    [0.0, 0.387412340661538, 0.7158446643589702, 0.9352961270557907, 1.012357232888872, 0.9352961270557909, 0.7158446643589702, 0.387412340661538, 0.0],
                                    [0.0, 0.3579223321794851, 0.6613542338586643, 0.864100948623921, 0.9352961270557909, 0.864100948623921, 0.6613542338586644, 0.35792233217948516, 0.0],
                                    [0.0, 0.2739418931971263, 0.5061786164444358, 0.6613542338586643, 0.7158446643589701, 0.6613542338586644, 0.506178616444436, 0.27394189319712636, 0.0],
                                    [0.0, 0.14825628426495077, 0.2739418931971263, 0.35792233217948505, 0.387412340661538, 0.3579223321794851, 0.27394189319712636, 0.1482562842649508, 0.0],
                                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]]);
                                    
    assert!(
        result_matrix == matrix.subview(Axis(0), results.m)
    );
}

#[test]
fn test_parallel_iterators_jaconi_func(){
    let option      = Options{
            number: 2,
            method: 2,
            interlines: 0,
            inf_func: 1,
            termination: 2,
            term_precision: 0.0,
            term_iteration: 45,
    };

    let elements = (option.interlines * 8) + 9 - 1;
    let arguments = CalcArguments {
            n: elements as usize,
            num_matrices: option.method + 1,
            h: 1.0 / elements as f64
    };

    let mut results = CalcResults{ ..Default::default()}; 
    let shape = (2, arguments.n+1, arguments.n+1);
    let mut matrix  = Array::<f64, _>::zeros(shape); 
    init_matrix::init_all(&mut matrix.view_mut(), &arguments);

    parallel::calc_with_iterators(&option, &mut results, &arguments, &mut matrix.view_mut());
    
    let     result_matrix = arr2(&[[1.0, 0.875, 0.75, 0.625, 0.5, 0.375, 0.25, 0.125, 0.0],
                                    [0.875, 0.7779749494706896, 0.6814295246458031, 0.585843350772365, 0.4914150839097391, 0.39834338057468743, 0.3064295693492866, 0.21547497927301196, 0.125],
                                    [0.75, 0.6814295246458031, 0.6138183007004538, 0.5478446097937704, 0.48418673290871084, 0.42284465449725395, 0.3638183603050986, 0.3064295693492866, 0.25],
                                    [0.625, 0.585843350772365, 0.5478446097937704, 0.5121616839410588, 0.4792741821324045, 0.44966171374338115, 0.42284465449725395, 0.3983433805746875, 0.375],
                                    [0.5, 0.4914150839097391, 0.48418673290871084, 0.47927418213240447, 0.4776366654225891, 0.47927418213240447, 0.48418673290871084, 0.4914150839097391, 0.5],
                                    [0.375, 0.39834338057468743, 0.42284465449725395, 0.44966171374338115, 0.4792741821324045, 0.5121616839410588, 0.5478446097937704, 0.585843350772365, 0.625],
                                    [0.25, 0.30642956934928667, 0.3638183603050986, 0.42284465449725395, 0.4841867329087109, 0.5478446097937704, 0.6138183007004538, 0.6814295246458031, 0.75],
                                    [0.125, 0.215474979273012, 0.3064295693492866, 0.3983433805746875, 0.49141508390973904, 0.585843350772365, 0.6814295246458031, 0.7779749494706896, 0.875],
                                    [0.0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0]]);
    
    println!("{}", matrix.subview(Axis(0), results.m));

    assert!(
        result_matrix == matrix.subview(Axis(0), results.m)
    );
}


/* =========== ZIP =========== */
#[test]
fn test_serial_zip_jaconi(){
    let threashold = 2.5e-16;
    let option      = Options{
            number: 1,
            method: 2,
            interlines: 0,
            inf_func: 2,
            termination: 1,
            term_precision: 5e-5,
            term_iteration: 200000,
    };

    let elements = (option.interlines * 8) + 9 - 1;
    let arguments = CalcArguments {
            n: elements as usize,
            num_matrices: option.method + 1,
            h: 1.0 / elements as f64
    };

    let mut results = CalcResults{ ..Default::default()}; 
    let shape = (arguments.n+1, arguments.n+1);
    let mut matrix  = Array::<f64, _>::zeros(shape);
    
    serial::calc_with_zip(&option, &mut results, &arguments, &mut matrix.view_mut());
    
    let mut result_matrix = arr2(&[[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                                    [0.0, 0.14825628426495077, 0.2739418931971263, 0.3579223321794851, 0.387412340661538, 0.3579223321794851, 0.2739418931971263, 0.14825628426495077, 0.0],
                                    [0.0, 0.2739418931971263, 0.5061786164444358, 0.6613542338586643, 0.7158446643589702, 0.6613542338586643, 0.5061786164444358, 0.2739418931971263, 0.0],
                                    [0.0, 0.3579223321794851, 0.6613542338586643, 0.8641009486239211, 0.9352961270557907, 0.8641009486239211, 0.6613542338586643, 0.3579223321794851, 0.0],
                                    [0.0, 0.387412340661538, 0.7158446643589702, 0.9352961270557907, 1.012357232888872, 0.9352961270557909, 0.7158446643589702, 0.387412340661538, 0.0],
                                    [0.0, 0.3579223321794851, 0.6613542338586643, 0.864100948623921, 0.9352961270557909, 0.864100948623921, 0.6613542338586644, 0.35792233217948516, 0.0],
                                    [0.0, 0.2739418931971263, 0.5061786164444358, 0.6613542338586643, 0.7158446643589701, 0.6613542338586644, 0.506178616444436, 0.27394189319712636, 0.0],
                                    [0.0, 0.14825628426495077, 0.2739418931971263, 0.35792233217948505, 0.387412340661538, 0.3579223321794851, 0.27394189319712636, 0.1482562842649508, 0.0],
                                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]]);

     result_matrix.zip_mut_with(&matrix, |x, &y|{ *x = if (*x - y).abs() < threashold {0.0}else{(*x - y).abs()}});
    println!("{:e}", result_matrix);
    let zero  = Array::<f64, _>::zeros(shape);
    assert!(
         result_matrix == zero
    );
}

#[test]
fn test_serial_zip_jaconi_func(){
    let threashold = 2.5e-16;
    let option      = Options{
            number: 1,
            method: 2,
            interlines: 0,
            inf_func: 1,
            termination: 2,
            term_precision: 0.0,
            term_iteration: 45,
    };

    let elements = (option.interlines * 8) + 9 - 1;
    let arguments = CalcArguments {
            n: elements as usize,
            num_matrices: option.method + 1,
            h: 1.0 / elements as f64
    };

    let mut results = CalcResults{ ..Default::default()}; 
    let shape = (arguments.n+1, arguments.n+1);
    let mut matrix  = Array::<f64, _>::zeros(shape); 

    init_matrix::init_all_dim2(&mut matrix.view_mut(), &arguments);
    
    serial::calc_with_zip(&&option, &mut results, &arguments, &mut matrix.view_mut());
    
    let mut  result_matrix = arr2(&[[1.0, 0.875, 0.75, 0.625, 0.5, 0.375, 0.25, 0.125, 0.0],
                                    [0.875, 0.7779749494706896, 0.6814295246458031, 0.585843350772365, 0.4914150839097391, 0.39834338057468743, 0.3064295693492866, 0.21547497927301196, 0.125],
                                    [0.75, 0.6814295246458031, 0.6138183007004538, 0.5478446097937704, 0.48418673290871084, 0.42284465449725395, 0.3638183603050986, 0.3064295693492866, 0.25],
                                    [0.625, 0.585843350772365, 0.5478446097937704, 0.5121616839410588, 0.4792741821324045, 0.44966171374338115, 0.42284465449725395, 0.3983433805746875, 0.375],
                                    [0.5, 0.4914150839097391, 0.48418673290871084, 0.47927418213240447, 0.4776366654225891, 0.47927418213240447, 0.48418673290871084, 0.4914150839097391, 0.5],
                                    [0.375, 0.39834338057468743, 0.42284465449725395, 0.44966171374338115, 0.4792741821324045, 0.5121616839410588, 0.5478446097937704, 0.585843350772365, 0.625],
                                    [0.25, 0.30642956934928667, 0.3638183603050986, 0.42284465449725395, 0.4841867329087109, 0.5478446097937704, 0.6138183007004538, 0.6814295246458031, 0.75],
                                    [0.125, 0.215474979273012, 0.3064295693492866, 0.3983433805746875, 0.49141508390973904, 0.585843350772365, 0.6814295246458031, 0.7779749494706896, 0.875],
                                    [0.0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0]]);

    result_matrix.zip_mut_with(&matrix, |x, &y|{ *x = if (*x - y).abs() < threashold {0.0}else{(*x - y).abs()}});
    println!("{:e}", result_matrix);
    let zero  = Array::<f64, _>::zeros(shape);
    assert!(
         result_matrix == zero
    );
}

#[test]
fn test_parallel_zip_jaconi(){
    let threashold = 2.5e-16;
    let option      = Options{
            number: 3,
            method: 2,
            interlines: 0,
            inf_func: 2,
            termination: 2,
            term_precision: 0.0,
            term_iteration: 94,
    };

    let elements = (option.interlines * 8) + 9 - 1;
    let arguments = CalcArguments {
            n: elements as usize,
            num_matrices: option.method + 1,
            h: 1.0 / elements as f64
    };

    let mut results = CalcResults{ ..Default::default()}; 
    let shape = (arguments.n+1, arguments.n+1);
    let mut matrix  = Array::<f64, _>::zeros(shape); 
    
    parallel::calc_with_zip(&&option, &mut results, &arguments, &mut matrix.view_mut());
    
    let mut result_matrix = arr2(&[[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                                    [0.0, 0.14825628426495077, 0.2739418931971263, 0.3579223321794851, 0.387412340661538, 0.3579223321794851, 0.2739418931971263, 0.14825628426495077, 0.0],
                                    [0.0, 0.2739418931971263, 0.5061786164444358, 0.6613542338586643, 0.7158446643589702, 0.6613542338586643, 0.5061786164444358, 0.2739418931971263, 0.0],
                                    [0.0, 0.3579223321794851, 0.6613542338586643, 0.8641009486239211, 0.9352961270557907, 0.8641009486239211, 0.6613542338586643, 0.3579223321794851, 0.0],
                                    [0.0, 0.387412340661538, 0.7158446643589702, 0.9352961270557907, 1.012357232888872, 0.9352961270557909, 0.7158446643589702, 0.387412340661538, 0.0],
                                    [0.0, 0.3579223321794851, 0.6613542338586643, 0.864100948623921, 0.9352961270557909, 0.864100948623921, 0.6613542338586644, 0.35792233217948516, 0.0],
                                    [0.0, 0.2739418931971263, 0.5061786164444358, 0.6613542338586643, 0.7158446643589701, 0.6613542338586644, 0.506178616444436, 0.27394189319712636, 0.0],
                                    [0.0, 0.14825628426495077, 0.2739418931971263, 0.35792233217948505, 0.387412340661538, 0.3579223321794851, 0.27394189319712636, 0.1482562842649508, 0.0],
                                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]]);

    result_matrix.zip_mut_with(&matrix, |x, &y|{ *x = if (*x - y).abs() < threashold {0.0}else{(*x - y).abs()}});
    println!("{:e}", result_matrix);
    let zero  = Array::<f64, _>::zeros(shape);
    assert!(
         result_matrix == zero
    );
}

#[test]
fn test_parallel_zip_jaconi_func(){
    let threashold = 2.5e-16;
    let option      = Options{
            number: 4,
            method: 2,
            interlines: 0,
            inf_func: 1,
            termination: 2,
            term_precision: 0.0,
            term_iteration: 45,
    };

    let elements = (option.interlines * 8) + 9 - 1;
    let arguments = CalcArguments {
            n: elements as usize,
            num_matrices: option.method + 1,
            h: 1.0 / elements as f64
    };

    let mut results = CalcResults{ ..Default::default()}; 
    let shape = (arguments.n+1, arguments.n+1);
    let mut matrix  = Array::<f64, _>::zeros(shape); 

    init_matrix::init_all_dim2(&mut matrix.view_mut(), &arguments);
    
    parallel::calc_with_zip(&&option, &mut results, &arguments, &mut matrix.view_mut());
    
    let mut result_matrix = arr2(&[[1.0, 0.875, 0.75, 0.625, 0.5, 0.375, 0.25, 0.125, 0.0],
                                    [0.875, 0.7779749494706896, 0.6814295246458031, 0.585843350772365, 0.4914150839097391, 0.39834338057468743, 0.3064295693492866, 0.21547497927301196, 0.125],
                                    [0.75, 0.6814295246458031, 0.6138183007004538, 0.5478446097937704, 0.48418673290871084, 0.42284465449725395, 0.3638183603050986, 0.3064295693492866, 0.25],
                                    [0.625, 0.585843350772365, 0.5478446097937704, 0.5121616839410588, 0.4792741821324045, 0.44966171374338115, 0.42284465449725395, 0.3983433805746875, 0.375],
                                    [0.5, 0.4914150839097391, 0.48418673290871084, 0.47927418213240447, 0.4776366654225891, 0.47927418213240447, 0.48418673290871084, 0.4914150839097391, 0.5],
                                    [0.375, 0.39834338057468743, 0.42284465449725395, 0.44966171374338115, 0.4792741821324045, 0.5121616839410588, 0.5478446097937704, 0.585843350772365, 0.625],
                                    [0.25, 0.30642956934928667, 0.3638183603050986, 0.42284465449725395, 0.4841867329087109, 0.5478446097937704, 0.6138183007004538, 0.6814295246458031, 0.75],
                                    [0.125, 0.215474979273012, 0.3064295693492866, 0.3983433805746875, 0.49141508390973904, 0.585843350772365, 0.6814295246458031, 0.7779749494706896, 0.875],
                                    [0.0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0]]);

    result_matrix.zip_mut_with(&matrix, |x, &y|{ *x = if (*x - y).abs() < threashold {0.0}else{(*x - y).abs()}});
    println!("{:e}", result_matrix);
    let zero  = Array::<f64, _>::zeros(shape);
    assert!(
         result_matrix == zero
    );
}




/* =========== NEGATIV TESTS =========== */
#[should_panic]
#[test]
fn negtest_serial_wget(){
    change_index_checking(false);
    let option      = Options{
            number: 1,
            method: 1,
            interlines: 0,
            inf_func: 1,
            termination: 2,
            term_precision: 0.0,
            term_iteration: 45,
    };

    let elements = (option.interlines * 8) + 9 - 1;
    let arguments = CalcArguments {
            n: elements as usize,
            num_matrices: option.method + 1,
            h: 1.0 / elements as f64
    };

    let mut results = CalcResults{ ..Default::default()}; 

//TEST 1
    let shape = (0,arguments.n+1, arguments.n+1);
    let mut matrix  = Array::<f64, _>::zeros(shape);
    
    serial::calc_with_get(&option, &mut results, &arguments, &mut matrix.view_mut());
    
//TEST 2
    let shape = (2,arguments.n+2, arguments.n+1);
    let mut matrix  = Array::<f64, _>::zeros(shape);
    serial::calc_with_get(&option, &mut results, &arguments, &mut matrix.view_mut());

//TEST 2
    let shape = (2,arguments.n+2, arguments.n+2);
    let mut matrix  = Array::<f64, _>::zeros(shape);
    serial::calc_with_get(&option, &mut results, &arguments, &mut matrix.view_mut());
}

#[should_panic]
#[test]
fn negtest_serial_wuget(){
    change_index_checking(false);
    let option      = Options{
            number: 1,
            method: 1,
            interlines: 0,
            inf_func: 1,
            termination: 2,
            term_precision: 0.0,
            term_iteration: 45,
    };

    let elements = (option.interlines * 8) + 9 - 1;
    let arguments = CalcArguments {
            n: elements as usize,
            num_matrices: option.method + 1,
            h: 1.0 / elements as f64
    };

    let mut results = CalcResults{ ..Default::default()}; 

//TEST 1
    let shape = (0,arguments.n+1, arguments.n+1);
    let mut matrix  = Array::<f64, _>::zeros(shape);
    
    serial::calc_with_get(&option, &mut results, &arguments, &mut matrix.view_mut());
    
    let shape = (2,arguments.n+2, arguments.n+1);
    let mut matrix  = Array::<f64, _>::zeros(shape);
    serial::calc_with_get(&option, &mut results, &arguments, &mut matrix.view_mut());

//TEST 2
    let shape = (2,arguments.n+2, arguments.n+2);
    let mut matrix  = Array::<f64, _>::zeros(shape);
    serial::calc_with_get(&option, &mut results, &arguments, &mut matrix.view_mut());
}

//calc_iterator can ignore the errors and will not panic,
    // but will return an useless result
    // to panic here the matrix shape needs to be cheked in calc methode
    // #[should_panic]
    // #[test]
    // fn negtest_serial_iterators(){
    //     change_index_checking(false);
    //     let option      = Options{
    //             number: 1,
    //             method: 1,
    //             interlines: 0,
    //             inf_func: 2,
    //             termination: 2,
    //             term_precision: 0.0,
    //             term_iteration: 45,
    //     };

    //     let elements = (option.interlines * 8) + 9 - 1;
    //     let arguments = CalcArguments {
    //             n: elements as usize,
    //             num_matrices: option.method + 1,
    //             h: 1.0 / elements as f64
    //     };

    //     let mut results = CalcResults{ ..Default::default()}; 

    // //TEST 1
    //     {
    //         let shape = (1, 0, arguments.n+1);
    //         let mut matrix  = Array::<f64, _>::zeros(shape);
            
    //         serial::calc_with_iterators(&option, &mut results, &arguments, &mut matrix.view_mut());
    //         println!("Test 1 : {}", matrix);
    //     }
    // //TEST 2
    //     {
    //         let shape = (3, arguments.n+2, arguments.n+1);
    //         let mut matrix  = Array::<f64, _>::zeros(shape);
    //         serial::calc_with_iterators(&option, &mut results, &arguments, &mut matrix.view_mut());

    //         println!("Test 2 : {}", matrix);
    //     }
    // //TEST 2
    //     {
    //         let shape = (2, arguments.n+2, arguments.n+2);
    //         let mut matrix  = Array::<f64, _>::zeros(shape);
    //         serial::calc_with_iterators(&option, &mut results, &arguments, &mut matrix.view_mut());
    //         println!("Test 3 : {}", matrix);
    //     }
// }

#[should_panic]
#[test]
fn negtest_serial_zip(){
    use pde_solver::basis::*;

    change_index_checking(false);
    let mut option      = Options{
            number: 1,
            method: 1,
            interlines: 0,
            inf_func: 2,
            termination: 2,
            term_precision: 0.0,
            term_iteration: 45,
    };

    let elements = (option.interlines * 8) + 9 - 1;
    let arguments = CalcArguments {
            n: elements as usize,
            num_matrices: option.method + 1,
            h: 1.0 / elements as f64
    };

    let mut results = CalcResults{ ..Default::default()}; 

//TEST 1
    let shape = (0, arguments.n+1);
    let mut matrix  = Array::<f64, _>::zeros(shape);
    
    serial::calc_with_zip(&option, &mut results, &arguments, &mut matrix.view_mut());
    
//TEST 2

    option.inf_func = METH_GAUSS_SEIDEL;
    let shape = (arguments.n+1, arguments.n+1);
    let mut matrix  = Array::<f64, _>::zeros(shape);
    serial::calc_with_zip(&option, &mut results, &arguments, &mut matrix.view_mut());
}